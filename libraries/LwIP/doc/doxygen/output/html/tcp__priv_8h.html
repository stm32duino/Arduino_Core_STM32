<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>lwIP 2.0.0: src/include/lwip/priv/tcp_priv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP 2.0.0
   &#160;<span id="projectnumber">lwIP 2.0.0</span>
   </div>
   <div id="projectbrief">LightweightIPstack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tcp__priv_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tcp_priv.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h.html">lwip/opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tcp_8h.html">lwip/tcp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem_8h.html">lwip/mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pbuf_8h.html">lwip/pbuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip_8h.html">lwip/ip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="icmp_8h.html">lwip/icmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="err_8h.html">lwip/err.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6_8h.html">lwip/ip6.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6__addr_8h.html">lwip/ip6_addr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="prot_2tcp_8h.html">lwip/prot/tcp.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afbd7a2997e3a3b7569efc3298e2e409f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#afbd7a2997e3a3b7569efc3298e2e409f">tcp_do_output_nagle</a>(tpcb)</td></tr>
<tr class="separator:afbd7a2997e3a3b7569efc3298e2e409f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dbdaeac3e25f5badf3a763a1b0b990"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#ac9dbdaeac3e25f5badf3a763a1b0b990">TF_RESET</a>&#160;&#160;&#160;(u8_t)0x08U   /* Connection was reset. */</td></tr>
<tr class="separator:ac9dbdaeac3e25f5badf3a763a1b0b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a6e9966d03c3326b9e0568666bb69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a178a6e9966d03c3326b9e0568666bb69">TCP_OVERSIZE_DBGCHECK</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a178a6e9966d03c3326b9e0568666bb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c47b916a8a25f82d2063335033aee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#aea0c47b916a8a25f82d2063335033aee">TCP_CHECKSUM_ON_COPY</a>&#160;&#160;&#160;(<a class="el" href="group__lwip__opts__checksum.html#ga9f60183f0442bdbeefd6b395c6647613">LWIP_CHECKSUM_ON_COPY</a> &amp;&amp; <a class="el" href="group__lwip__opts__checksum.html#ga800069963cc4552b99235237c22f00bb">CHECKSUM_GEN_TCP</a>)</td></tr>
<tr class="separator:aea0c47b916a8a25f82d2063335033aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc99c343efc6c81abf60bb62b361dd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#abdc99c343efc6c81abf60bb62b361dd8">TCP_BUILD_MSS_OPTION</a>(mss)&#160;&#160;&#160;lwip_htonl(0x02040000 | ((mss) &amp; 0xFFFF))</td></tr>
<tr class="separator:abdc99c343efc6c81abf60bb62b361dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51de4ded7d342456d31722493c92c969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a51de4ded7d342456d31722493c92c969">tcp_init</a> (void)</td></tr>
<tr class="separator:a51de4ded7d342456d31722493c92c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3846a756b13214ed88ea47d0ff8279eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr</a> (void)</td></tr>
<tr class="separator:a3846a756b13214ed88ea47d0ff8279eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421fb42ef919018e14ae413adfee9905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr</a> (void)</td></tr>
<tr class="separator:a421fb42ef919018e14ae413adfee9905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf446b07e52161b8a53cea07bc6c366d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#abf446b07e52161b8a53cea07bc6c366d">tcp_fasttmr</a> (void)</td></tr>
<tr class="separator:abf446b07e52161b8a53cea07bc6c366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae0268e59fda0665fdd08c6e77ec547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a5ae0268e59fda0665fdd08c6e77ec547">tcp_txnow</a> (void)</td></tr>
<tr class="separator:a5ae0268e59fda0665fdd08c6e77ec547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70c3c99d9dd6b07f7e11f7ba5eedcb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#ae70c3c99d9dd6b07f7e11f7ba5eedcb5">tcp_input</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, struct <a class="el" href="structnetif.html">netif</a> *inp)</td></tr>
<tr class="separator:ae70c3c99d9dd6b07f7e11f7ba5eedcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd6830a42b3c464b5a72f62ae312d0a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a1dd6830a42b3c464b5a72f62ae312d0a">tcp_alloc</a> (u8_t prio)</td></tr>
<tr class="separator:a1dd6830a42b3c464b5a72f62ae312d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f0f1ca01dbccd680eaa2d8433cd7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#ae4f0f1ca01dbccd680eaa2d8433cd7fe">tcp_abandon</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int reset)</td></tr>
<tr class="separator:ae4f0f1ca01dbccd680eaa2d8433cd7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefde3e34b2cc8df9654986484c44a996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#aefde3e34b2cc8df9654986484c44a996">tcp_send_empty_ack</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aefde3e34b2cc8df9654986484c44a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0520917abc5f5ae56e39d632131a69b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a0520917abc5f5ae56e39d632131a69b7">tcp_rexmit</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a0520917abc5f5ae56e39d632131a69b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ef9c8ab4629eb721987ae316b9f30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#ab5ef9c8ab4629eb721987ae316b9f30f">tcp_rexmit_rto</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ab5ef9c8ab4629eb721987ae316b9f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ee7b4d59f125cc8bfac3bb5ca3937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#adb6ee7b4d59f125cc8bfac3bb5ca3937">tcp_rexmit_fast</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:adb6ee7b4d59f125cc8bfac3bb5ca3937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2c254b779db4e517cb34e41301588d"><td class="memItemLeft" align="right" valign="top">u32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a6d2c254b779db4e517cb34e41301588d">tcp_update_rcv_ann_wnd</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a6d2c254b779db4e517cb34e41301588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0075b56ad4b0eca7c9d439cf150e1973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a0075b56ad4b0eca7c9d439cf150e1973">tcp_process_refused_data</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a0075b56ad4b0eca7c9d439cf150e1973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc672b9d14a65e61040707c45302ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a44fc672b9d14a65e61040707c45302ba">tcp_pcb_purge</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a44fc672b9d14a65e61040707c45302ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaef096f6a03bf5b778329bb66ee06f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#aaaef096f6a03bf5b778329bb66ee06f6">tcp_pcb_remove</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **pcblist, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aaaef096f6a03bf5b778329bb66ee06f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9bb9809769197bce9b2499d55cf28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a3d9bb9809769197bce9b2499d55cf28c">tcp_segs_free</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:a3d9bb9809769197bce9b2499d55cf28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6283651b26f74dba2444159aee88b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#ac6283651b26f74dba2444159aee88b20">tcp_seg_free</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:ac6283651b26f74dba2444159aee88b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569d79451d2570e4ef406775725ef6ef"><td class="memItemLeft" align="right" valign="top">struct tcp_seg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a569d79451d2570e4ef406775725ef6ef">tcp_seg_copy</a> (struct tcp_seg *seg)</td></tr>
<tr class="separator:a569d79451d2570e4ef406775725ef6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ba9d645a8910436c3d7cf13dba342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#af40ba9d645a8910436c3d7cf13dba342">tcp_send_fin</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:af40ba9d645a8910436c3d7cf13dba342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d5d552647d567095876aab202bfd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#aa7d5d552647d567095876aab202bfd1a">tcp_enqueue_flags</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t flags)</td></tr>
<tr class="separator:aa7d5d552647d567095876aab202bfd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe40709e0e5c0523b674775da989a252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#abe40709e0e5c0523b674775da989a252">tcp_rst</a> (u32_t seqno, u32_t ackno, const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *local_ip, const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *remote_ip, u16_t local_port, u16_t remote_port)</td></tr>
<tr class="separator:abe40709e0e5c0523b674775da989a252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5427fc45c0694592419b03694b95af7"><td class="memItemLeft" align="right" valign="top">u32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#af5427fc45c0694592419b03694b95af7">tcp_next_iss</a> (void)</td></tr>
<tr class="separator:af5427fc45c0694592419b03694b95af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8bb5fc8522515aa35d305774cc5332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a0d8bb5fc8522515aa35d305774cc5332">tcp_keepalive</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a0d8bb5fc8522515aa35d305774cc5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20490aa45c771c38ce8ad3031cbdf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a6c20490aa45c771c38ce8ad3031cbdf6">tcp_zero_window_probe</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a6c20490aa45c771c38ce8ad3031cbdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aecf22f31b2940133dd60246589fd5"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#ad7aecf22f31b2940133dd60246589fd5">tcp_eff_send_mss_impl</a> (u16_t sendmss, const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *dest, const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *src)</td></tr>
<tr class="separator:ad7aecf22f31b2940133dd60246589fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb3f604fc8d20870d8cab291da5701c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a0cb3f604fc8d20870d8cab291da5701c">tcp_recv_null</a> (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> err)</td></tr>
<tr class="separator:a0cb3f604fc8d20870d8cab291da5701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8181bc316fdf61b85f787c5cadfcd249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a8181bc316fdf61b85f787c5cadfcd249">tcp_timer_needed</a> (void)</td></tr>
<tr class="separator:a8181bc316fdf61b85f787c5cadfcd249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0c2d1ad02134c79fc72fe95ee2a703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a4d0c2d1ad02134c79fc72fe95ee2a703">tcp_netif_ip_addr_changed</a> (const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *old_addr, const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *new_addr)</td></tr>
<tr class="separator:a4d0c2d1ad02134c79fc72fe95ee2a703"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1b42a7ac0fc173a42d575f86853d32a8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a1b42a7ac0fc173a42d575f86853d32a8">tcp_bound_pcbs</a></td></tr>
<tr class="separator:a1b42a7ac0fc173a42d575f86853d32a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fe1350e510d4308ac9969ffb4c9c81"><td class="memItemLeft" align="right" valign="top">union tcp_listen_pcbs_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a></td></tr>
<tr class="separator:a96fe1350e510d4308ac9969ffb4c9c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c09dbae67ccc06b659d9f1a388f911"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a></td></tr>
<tr class="separator:a78c09dbae67ccc06b659d9f1a388f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a522a66c5e1f1a4e28fe7a672cc64e3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a></td></tr>
<tr class="separator:a9a522a66c5e1f1a4e28fe7a672cc64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e1079ab223e1cb27208c45e3c84df7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__priv_8h.html#af5e1079ab223e1cb27208c45e3c84df7">tcp_pcb_lists</a> [4]</td></tr>
<tr class="separator:af5e1079ab223e1cb27208c45e3c84df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TCP internal implementations (do not use in application code) </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="abdc99c343efc6c81abf60bb62b361dd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_BUILD_MSS_OPTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mss</td><td>)</td>
          <td>&#160;&#160;&#160;lwip_htonl(0x02040000 | ((mss) &amp; 0xFFFF))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns a TCP header option for MSS in an u32_t </p>

</div>
</div>
<a class="anchor" id="aea0c47b916a8a25f82d2063335033aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_CHECKSUM_ON_COPY&#160;&#160;&#160;(<a class="el" href="group__lwip__opts__checksum.html#ga9f60183f0442bdbeefd6b395c6647613">LWIP_CHECKSUM_ON_COPY</a> &amp;&amp; <a class="el" href="group__lwip__opts__checksum.html#ga800069963cc4552b99235237c22f00bb">CHECKSUM_GEN_TCP</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Don't generate checksum on copy if CHECKSUM_GEN_TCP is disabled </p>

</div>
</div>
<a class="anchor" id="afbd7a2997e3a3b7569efc3298e2e409f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_do_output_nagle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tpcb</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((((tpcb)-&gt;unacked == NULL) || \</div><div class="line">                            ((tpcb)-&gt;flags &amp; (TF_NODELAY | TF_INFR)) || \</div><div class="line">                            (((tpcb)-&gt;unsent != NULL) &amp;&amp; (((tpcb)-&gt;unsent-&gt;next != NULL) || \</div><div class="line">                              ((tpcb)-&gt;unsent-&gt;len &gt;= (tpcb)-&gt;mss))) || \</div><div class="line">                            ((tcp_sndbuf(tpcb) == 0) || (tcp_sndqueuelen(tpcb) &gt;= <a class="code" href="group__lwip__opts__tcp.html#ga9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>)) \</div><div class="line">                            ) ? 1 : 0)</div><div class="ttc" id="group__lwip__opts__tcp_html_ga9beaa47832ead4180981bfbf71074904"><div class="ttname"><a href="group__lwip__opts__tcp.html#ga9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a></div><div class="ttdeci">#define TCP_SND_QUEUELEN</div><div class="ttdef"><b>Definition:</b> opt.h:1196</div></div>
</div><!-- fragment --><p>This is the Nagle algorithm: try to combine user data to send as few TCP segments as possible. Only send if</p><ul>
<li>no previously transmitted data on the connection remains unacknowledged or</li>
<li>the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or</li>
<li>the only unsent segment is at least pcb-&gt;mss bytes long (or there is more than one unsent segment - with lwIP, this can happen although unsent-&gt;len &lt; mss)</li>
<li>or if we are in fast-retransmit (TF_INFR) </li>
</ul>

</div>
</div>
<a class="anchor" id="a178a6e9966d03c3326b9e0568666bb69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_OVERSIZE_DBGCHECK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enabled extra-check for TCP_OVERSIZE if LWIP_DEBUG is enabled </p>

</div>
</div>
<a class="anchor" id="ac9dbdaeac3e25f5badf3a763a1b0b990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TF_RESET&#160;&#160;&#160;(u8_t)0x08U   /* Connection was reset. */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used on input processing, not on pcb-&gt;flags </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae4f0f1ca01dbccd680eaa2d8433cd7fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_abandon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abandons a connection and optionally sends a RST to the remote host. Deletes the local protocol control block. This is done when a connection is killed because of shortage of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to abort </td></tr>
    <tr><td class="paramname">reset</td><td>boolean to indicate whether a reset should be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dd6830a42b3c464b5a72f62ae312d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_alloc </td>
          <td>(</td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>priority for the new pcb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that initially is in state CLOSED </dd></dl>

</div>
</div>
<a class="anchor" id="ad7aecf22f31b2940133dd60246589fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t tcp_eff_send_mss_impl </td>
          <td>(</td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>sendmss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the effective send mss that can be used for a specific IP address by using ip_route to determine the netif used to send to the address and calculating the minimum of TCP_MSS and that netif's mtu (if set). </p>

</div>
</div>
<a class="anchor" id="aa7d5d552647d567095876aab202bfd1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_enqueue_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue TCP options for transmission.</p>
<p>Called by <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect()</a>, tcp_listen_input(), and tcp_send_ctrl().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection. </td></tr>
    <tr><td class="paramname">flags</td><td>TCP header flags to set in the outgoing segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf446b07e52161b8a53cea07bc6c366d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_fasttmr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is called every TCP_FAST_INTERVAL (250 ms) and process data previously "refused" by upper layer (application) and sends delayed ACKs.</p>
<p>Automatically called from <a class="el" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

</div>
</div>
<a class="anchor" id="a51de4ded7d342456d31722493c92c969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize this module. </p>

</div>
</div>
<a class="anchor" id="ae70c3c99d9dd6b07f7e11f7ba5eedcb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_input </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>inp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The initial input processing of TCP. It verifies the TCP header, demultiplexes the segment between the PCBs and passes it on to tcp_process(), which implements the TCP finite state machine. This function is called by the IP layer (in <a class="el" href="group__lwip__nosys.html#ga3c420dab0c6760df099a2d688fa42a26">ip_input()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>received TCP segment to process (p-&gt;payload pointing to the TCP header) </td></tr>
    <tr><td class="paramname">inp</td><td>network interface on which this segment was received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d8bb5fc8522515aa35d305774cc5332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_keepalive </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send keepalive packets to keep a connection active although no data is sent over it.</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to send a keepalive packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d0c2d1ad02134c79fc72fe95ee2a703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_netif_ip_addr_changed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>old_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>new_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called from <a class="el" href="netif_8c.html">netif.c</a> when address is changed or netif is removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_addr</td><td>IP address of the netif before change </td></tr>
    <tr><td class="paramname">new_addr</td><td>IP address of the netif after change or NULL if netif has been removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5427fc45c0694592419b03694b95af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_next_iss </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates a new initial sequence number for new connections.</p>
<dl class="section return"><dt>Returns</dt><dd>u32_t pseudo random sequence number </dd></dl>

</div>
</div>
<a class="anchor" id="a44fc672b9d14a65e61040707c45302ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_purge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges a TCP PCB. Removes any buffered data and frees the buffer memory (pcb-&gt;ooseq, pcb-&gt;unsent and pcb-&gt;unacked are freed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is not deallocated! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaef096f6a03bf5b778329bb66ee06f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **&#160;</td>
          <td class="paramname"><em>pcblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcblist</td><td>PCB list to purge. </td></tr>
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is NOT deallocated! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0075b56ad4b0eca7c9d439cf150e1973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_process_refused_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass pcb-&gt;refused_data to the recv callback </p>

</div>
</div>
<a class="anchor" id="a0cb3f604fc8d20870d8cab291da5701c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_recv_null </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default receive callback that is called if the user didn't register a recv callback for the pcb. </p>

</div>
</div>
<a class="anchor" id="a0520917abc5f5ae56e39d632131a69b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue the first unacked segment for retransmission</p>
<p>Called by tcp_receive() for fast retransmit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to retransmit the first unacked segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb6ee7b4d59f125cc8bfac3bb5ca3937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_fast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle retransmission after three dupacks received</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to retransmit the first unacked segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5ef9c8ab4629eb721987ae316b9f30f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_rto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue all unacked segments for retransmission</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a> for slow retransmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to re-enqueue all unacked segments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe40709e0e5c0523b674775da989a252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rst </td>
          <td>(</td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>seqno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>ackno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>local_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>remote_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>local_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>remote_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a TCP RESET packet (empty segment with RST flag set) either to abort a connection or to show that there is no matching local connection for a received segment.</p>
<p>Called by <a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort()</a> (to abort a local connection), <a class="el" href="tcp__in_8c.html#ae70c3c99d9dd6b07f7e11f7ba5eedcb5">tcp_input()</a> (if no matching local pcb was found), tcp_listen_input() (if incoming segment has ACK flag set) and tcp_process() (received segment in the wrong state)</p>
<p>Since a RST segment is in most cases not sent for an active connection, <a class="el" href="tcp__out_8c.html#abe40709e0e5c0523b674775da989a252">tcp_rst()</a> has a number of arguments that are taken from a <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for most other segment output functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqno</td><td>the sequence number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">ackno</td><td>the acknowledge number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">local_ip</td><td>the local IP address to send the segment from </td></tr>
    <tr><td class="paramname">remote_ip</td><td>the remote IP address to send the segment to </td></tr>
    <tr><td class="paramname">local_port</td><td>the local TCP port to send the segment from </td></tr>
    <tr><td class="paramname">remote_port</td><td>the remote TCP port to send the segment to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a569d79451d2570e4ef406775725ef6ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct tcp_seg* tcp_seg_copy </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *&#160;</td>
          <td class="paramname"><em>seg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the given TCP segment. The pbuf and data are not copied, only the pointers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>the old tcp_seg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of seg </dd></dl>

</div>
</div>
<a class="anchor" id="ac6283651b26f74dba2444159aee88b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_seg_free </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *&#160;</td>
          <td class="paramname"><em>seg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a TCP segment (tcp_seg structure).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>single tcp_seg to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d9bb9809769197bce9b2499d55cf28c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_segs_free </td>
          <td>(</td>
          <td class="paramtype">struct tcp_seg *&#160;</td>
          <td class="paramname"><em>seg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates a list of TCP segments (tcp_seg structures).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>tcp_seg list of TCP segments to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefde3e34b2cc8df9654986484c44a996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_send_empty_ack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an ACK without data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection to send the ACK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af40ba9d645a8910436c3d7cf13dba342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_send_fin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by <a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close()</a> to send a segment including FIN flag but not data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> over which to send a segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if sent, another err_t otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a421fb42ef919018e14ae413adfee9905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_slowtmr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called every 500 ms and implements the retransmission timer and the timer that removes PCBs that have been in TIME-WAIT for enough time. It also increments various timers such as the inactivity timer in each PCB.</p>
<p>Automatically called from <a class="el" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

</div>
</div>
<a class="anchor" id="a8181bc316fdf61b85f787c5cadfcd249"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_timer_needed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External function (implemented in timers.c), called when TCP detects that a timer is needed (i.e. active- or time-wait-pcb found).</p>
<p>Called from TCP_REG when registering a new PCB: the reason is to have the TCP timer only running when there are active (or time-wait) PCBs. </p>

</div>
</div>
<a class="anchor" id="a3846a756b13214ed88ea47d0ff8279eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_tmr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called periodically to dispatch TCP timers. </p>

</div>
</div>
<a class="anchor" id="a5ae0268e59fda0665fdd08c6e77ec547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_txnow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call tcp_output for all active pcbs that have TF_NAGLEMEMERR set </p>

</div>
</div>
<a class="anchor" id="a6d2c254b779db4e517cb34e41301588d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_update_rcv_ann_wnd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the state that tracks the available window space to advertise.</p>
<p>Returns how much extra window would be advertised if we sent an update now. </p>

</div>
</div>
<a class="anchor" id="a6c20490aa45c771c38ce8ad3031cbdf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_zero_window_probe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send persist timer zero-window probes to keep a connection active when a window update is lost.</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to send a zero-window probe packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a78c09dbae67ccc06b659d9f1a388f911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_active_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs that are in a state in which they accept or send data. </p>

</div>
</div>
<a class="anchor" id="a1b42a7ac0fc173a42d575f86853d32a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_bound_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs bound but not yet (connected || listening) </p>

</div>
</div>
<a class="anchor" id="a96fe1350e510d4308ac9969ffb4c9c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union tcp_listen_pcbs_t tcp_listen_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs in LISTEN state </p>

</div>
</div>
<a class="anchor" id="af5e1079ab223e1cb27208c45e3c84df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>** const tcp_pcb_lists[4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array with all (non-temporary) PCB lists, mainly used for smaller code size </p>

</div>
</div>
<a class="anchor" id="a9a522a66c5e1f1a4e28fe7a672cc64e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_tw_pcbs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of all TCP PCBs in TIME-WAIT state </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_4e6b3cf33a61b6caac9c8ac30c866f37.html">lwip</a></li><li class="navelem"><a class="el" href="dir_460c501b2432fc107adcb38111835e48.html">priv</a></li><li class="navelem"><a class="el" href="tcp__priv_8h.html">tcp_priv.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>lwIP 2.0.0: TCP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP 2.0.0
   &#160;<span id="projectnumber">lwIP 2.0.0</span>
   </div>
   <div id="projectbrief">LightweightIPstack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__tcp__raw.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TCP<div class="ingroups"><a class="el" href="group__callbackstyle__api.html">Callback-style APIs</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5b5c0093efff4466bda06d45f12a4633"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga5b5c0093efff4466bda06d45f12a4633">tcp_nagle_disable</a>(pcb)&#160;&#160;&#160;((pcb)-&gt;flags |= TF_NODELAY)</td></tr>
<tr class="separator:ga5b5c0093efff4466bda06d45f12a4633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dfcdb8a05533b07dca91cf7e784f88f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9dfcdb8a05533b07dca91cf7e784f88f">tcp_nagle_enable</a>(pcb)&#160;&#160;&#160;((pcb)-&gt;flags = (tcpflags_t)((pcb)-&gt;flags &amp; ~TF_NODELAY))</td></tr>
<tr class="separator:ga9dfcdb8a05533b07dca91cf7e784f88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9398061411b4af900160233aa3b1a286"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9398061411b4af900160233aa3b1a286">tcp_nagle_disabled</a>(pcb)&#160;&#160;&#160;(((pcb)-&gt;flags &amp; TF_NODELAY) != 0)</td></tr>
<tr class="separator:ga9398061411b4af900160233aa3b1a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2a4efb1fc15d7d85cb71cb2a1d1066"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen</a>(pcb)&#160;&#160;&#160;<a class="el" href="group__tcp__raw.html#gaeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a>(pcb, <a class="el" href="group__lwip__opts__tcp.html#ga93cce3f47e33df11248c908d1775bacf">TCP_DEFAULT_LISTEN_BACKLOG</a>)</td></tr>
<tr class="separator:ga6b2a4efb1fc15d7d85cb71cb2a1d1066"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga427b11c7b98c748ec487cd43093bd2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga427b11c7b98c748ec487cd43093bd2f8">tcp_backlog_delayed</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga427b11c7b98c748ec487cd43093bd2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619154658137a23839ca3b94882131ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga619154658137a23839ca3b94882131ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87093e137fcc53ea82a134a3f5b33623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga87093e137fcc53ea82a134a3f5b33623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b94d57f1891b9287f88525a2ac561dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga5b94d57f1891b9287f88525a2ac561dd">tcp_shutdown</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int shut_rx, int shut_tx)</td></tr>
<tr class="separator:ga5b94d57f1891b9287f88525a2ac561dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468c2260ddb01582e966ddcf3c25ce61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga468c2260ddb01582e966ddcf3c25ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *ipaddr, u16_t port)</td></tr>
<tr class="separator:gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff14f321d1eecd0431611f382fcd338"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gaeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t backlog)</td></tr>
<tr class="separator:gaeff14f321d1eecd0431611f382fcd338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdac0856a52b5789dc897d4c7137ec44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gabdac0856a52b5789dc897d4c7137ec44">tcp_recved</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t len)</td></tr>
<tr class="separator:gabdac0856a52b5789dc897d4c7137ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a31deea4cadacd39f9485f37cfdd012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *ipaddr, u16_t port, <a class="el" href="tcp_8h.html#a939867106bd492caf2d85852fb7f6ae8">tcp_connected_fn</a> connected)</td></tr>
<tr class="separator:ga9a31deea4cadacd39f9485f37cfdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7427c5d237fe66a8097bfa8d24ceb943"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga7427c5d237fe66a8097bfa8d24ceb943">tcp_new</a> (void)</td></tr>
<tr class="separator:ga7427c5d237fe66a8097bfa8d24ceb943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14e757a21a4a87c6aa52372c210b937"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gac14e757a21a4a87c6aa52372c210b937">tcp_new_ip_type</a> (u8_t type)</td></tr>
<tr class="separator:gac14e757a21a4a87c6aa52372c210b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, void *arg)</td></tr>
<tr class="separator:gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga8afd0b316a87a5eeff4726dc95006ed0">tcp_recv</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a780cfac08b02c66948ab94ea974202e8">tcp_recv_fn</a> <a class="el" href="group__socket.html#gadd7ae45df7c005619eb1126542231e9b">recv</a>)</td></tr>
<tr class="separator:ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1596332b93bb6249179f3b89f24bd808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga1596332b93bb6249179f3b89f24bd808">tcp_sent</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#aa60622ffaa099e97f66fb56e437fca18">tcp_sent_fn</a> sent)</td></tr>
<tr class="separator:ga1596332b93bb6249179f3b89f24bd808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gae1346c4e34d3bc7c01e1b47142ab3121">tcp_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a1b4f9e3551e575c0ef06d6daa7f06e55">tcp_err_fn</a> err)</td></tr>
<tr class="separator:gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gaff4c3e380fc60c8fb9b3aa95eda94c62">tcp_accept</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a00517abce6856d6c82f0efebdafb734d">tcp_accept_fn</a> <a class="el" href="group__socket.html#gade2b17671b5a4b18e941fbf7e1060310">accept</a>)</td></tr>
<tr class="separator:gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gafba47015098ed7ce523dcf7bdf70f7e5">tcp_poll</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a66deb97618a9cd9d57fca28c5245e073">tcp_poll_fn</a> poll, u8_t interval)</td></tr>
<tr class="separator:gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const void *arg, u16_t len, u8_t apiflags)</td></tr>
<tr class="separator:ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Transmission Control Protocol for IP<br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="raw_api.html">lwIP API</a> and <a class="el" href="group__netconn.html">Netconn API</a></dd></dl>
<p>Common functions for the TCP implementation, such as functinos for manipulating the data structures and the TCP timer functions. TCP functions related to input and output is found in <a class="el" href="tcp__in_8c.html">tcp_in.c</a> and <a class="el" href="tcp__out_8c.html">tcp_out.c</a> respectively.<br />
</p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6b2a4efb1fc15d7d85cb71cb2a1d1066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_listen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__tcp__raw.html#gaeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a>(pcb, <a class="el" href="group__lwip__opts__tcp.html#ga93cce3f47e33df11248c908d1775bacf">TCP_DEFAULT_LISTEN_BACKLOG</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5b5c0093efff4466bda06d45f12a4633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_nagle_disable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;((pcb)-&gt;flags |= TF_NODELAY)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9398061411b4af900160233aa3b1a286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_nagle_disabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;(((pcb)-&gt;flags &amp; TF_NODELAY) != 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9dfcdb8a05533b07dca91cf7e784f88f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_nagle_enable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;((pcb)-&gt;flags = (tcpflags_t)((pcb)-&gt;flags &amp; ~TF_NODELAY))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga468c2260ddb01582e966ddcf3c25ce61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_abort </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts the connection by sending a RST (reset) segment to the remote host. The pcb is deallocated. This function never fails.</p>
<p>ATTENTION: When calling this from one of the TCP callbacks, make sure you always return ERR_ABRT (and never return ERR_ABRT otherwise or you will risk accessing deallocated memory or memory leaks!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the tcp pcb to abort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaff4c3e380fc60c8fb9b3aa95eda94c62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_accept </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a00517abce6856d6c82f0efebdafb734d">tcp_accept_fn</a>&#160;</td>
          <td class="paramname"><em>accept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used for specifying the function that should be called when a LISTENing connection has been connected to another host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the accept callback </td></tr>
    <tr><td class="paramname">accept</td><td>callback function to call for this pcb when LISTENing connection has been connected to another host </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac10926e6f76f73e17c0d37aaab3e56b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_arg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to specify the argument that should be passed callback functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the callback argument </td></tr>
    <tr><td class="paramname">arg</td><td>void pointer argument to pass to callback functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga619154658137a23839ca3b94882131ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_backlog_accepted </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A delayed-accept a connection is accepted (or closed/aborted): decreases the number of outstanding connections after calling <a class="el" href="group__tcp__raw.html#ga427b11c7b98c748ec487cd43093bd2f8">tcp_backlog_delayed()</a>.</p>
<p>ATTENTION: the caller is responsible for calling <a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted()</a> or else the backlog feature will get out of sync!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the connection pcb which is now fully accepted (or closed/aborted) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga427b11c7b98c748ec487cd43093bd2f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_backlog_delayed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay accepting a connection in respect to the listen backlog: the number of outstanding connections is increased until <a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted()</a> is called.</p>
<p>ATTENTION: the caller is responsible for calling <a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted()</a> or else the backlog feature will get out of sync!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the connection pcb which is not fully accepted yet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf5aa67bd7fc66fef43f77a55a1201ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds the connection to a local port number and IP address. If the IP address is not given (i.e., ipaddr == NULL), the IP address of the outgoing network interface is used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to bind (no check is done whether this pcb is already bound!) </td></tr>
    <tr><td class="paramname">ipaddr</td><td>the local ip address to bind to (use IP4_ADDR_ANY to bind to any local address </td></tr>
    <tr><td class="paramname">port</td><td>the local port to bind to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_USE if the port is already in use ERR_VAL if bind failed because the PCB is not in a valid state ERR_OK if bound </dd></dl>

</div>
</div>
<a class="anchor" id="ga87093e137fcc53ea82a134a3f5b33623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the connection held by the PCB.</p>
<p>Listening pcbs are freed and may not be referenced any more. Connection pcbs are freed if not yet connected and may not be referenced any more. If a connection is established (at least SYN received or in a closing state), the connection is closed, and put in a closing state. The pcb is then automatically freed in <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a>. It is therefore unsafe to reference it (unless an error is returned).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if connection has been closed another err_t if closing failed and pcb is not freed </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a31deea4cadacd39f9485f37cfdd012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga44f9ada14c65d17aecf802d82eb273c5">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a939867106bd492caf2d85852fb7f6ae8">tcp_connected_fn</a>&#160;</td>
          <td class="paramname"><em>connected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to another host. The function given as the "connected" argument will be called when the connection has been established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> used to establish the connection </td></tr>
    <tr><td class="paramname">ipaddr</td><td>the remote ip address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>the remote tcp port to connect to </td></tr>
    <tr><td class="paramname">connected</td><td>callback function to call when connected (on error, the err calback will be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_VAL if invalid arguments are given ERR_OK if connect request has been sent other err_t values if connect request couldn't be sent </dd></dl>

</div>
</div>
<a class="anchor" id="gae1346c4e34d3bc7c01e1b47142ab3121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_err </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a1b4f9e3551e575c0ef06d6daa7f06e55">tcp_err_fn</a>&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to specify the function that should be called when a fatal error has occurred on the connection.</p>
<dl class="section note"><dt>Note</dt><dd>The corresponding pcb is already freed when this callback is called!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the err callback </td></tr>
    <tr><td class="paramname">err</td><td>callback function to call for this pcb when a fatal error has occurred on the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeff14f321d1eecd0431611f382fcd338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_listen_with_backlog </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the state of the connection to be LISTEN, which means that it is able to accept incoming connections. The protocol control block is reallocated in order to consume less memory. Setting the connection to LISTEN is an irreversible process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> </td></tr>
    <tr><td class="paramname">backlog</td><td>the incoming connections queue limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structtcp__pcb.html">tcp_pcb</a> used for listening, consumes less memory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> is freed. This function therefore has to be called like this: tpcb = <a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen(tpcb)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ga7427c5d237fe66a8097bfa8d24ceb943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new TCP protocol control block but doesn't place it on any of the TCP PCB lists. The pcb is not put on any list until binding using <a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind()</a>. </p>

</div>
</div>
<a class="anchor" id="gac14e757a21a4a87c6aa52372c210b937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_new_ip_type </td>
          <td>(</td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new TCP protocol control block but doesn't place it on any of the TCP PCB lists. The pcb is not put on any list until binding using <a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>IP address type, see <a class="el" href="group__ipaddr.html#gaf2142f0dfdcc938e2db16aa745ed585c">lwip_ip_addr_type</a> definitions. If you want to listen to IPv4 and IPv6 (dual-stack) connections, supply <a class="el" href="group__ipaddr.html#ggaf2142f0dfdcc938e2db16aa745ed585cac6b2c99cf920e08efcb55dc40e42944e">IPADDR_TYPE_ANY</a> as argument and bind to <a class="el" href="group__ipaddr.html#gabe43b154533b73585c4e58f568370ede">IP_ANY_TYPE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that initially is in state CLOSED </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cbcc6d628f644a530daf629fa3e5f7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_output </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find out what we can send and send it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection to send data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if data has been sent or nothing to send another err_t on error </dd></dl>

</div>
</div>
<a class="anchor" id="gafba47015098ed7ce523dcf7bdf70f7e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_poll </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a66deb97618a9cd9d57fca28c5245e073">tcp_poll_fn</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to specify the function that should be called periodically from TCP. The interval is specified in terms of the TCP coarse timer interval, which is called twice a second. </p>

</div>
</div>
<a class="anchor" id="ga8afd0b316a87a5eeff4726dc95006ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a780cfac08b02c66948ab94ea974202e8">tcp_recv_fn</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to specify the function that should be called when a TCP connection receives data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the recv callback </td></tr>
    <tr><td class="paramname">recv</td><td>callback function to call for this pcb when data is received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabdac0856a52b5789dc897d4c7137ec44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_recved </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called by the application when it has processed the data. The purpose is to advertise a larger window when the data has been processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which data is read </td></tr>
    <tr><td class="paramname">len</td><td>the amount of bytes that have been read by the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1596332b93bb6249179f3b89f24bd808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_sent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#aa60622ffaa099e97f66fb56e437fca18">tcp_sent_fn</a>&#160;</td>
          <td class="paramname"><em>sent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to specify the function that should be called when TCP data has been successfully delivered to the remote host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the sent callback </td></tr>
    <tr><td class="paramname">sent</td><td>callback function to call for this pcb when data is successfully sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b94d57f1891b9287f88525a2ac561dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_shutdown </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shut_rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shut_tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes all or part of a full-duplex connection of this PCB to be shut down. This doesn't deallocate the PCB unless shutting down both sides! Shutting down both sides is the same as calling tcp_close, so if it succeds, the PCB should not be referenced any more.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>PCB to shutdown </td></tr>
    <tr><td class="paramname">shut_rx</td><td>shut down receive side if this is != 0 </td></tr>
    <tr><td class="paramname">shut_tx</td><td>shut down send side if this is != 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if shutdown succeeded (or the PCB has already been shut down) another err_t on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b2aa0efbf10e254930332b7c89cd8c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>apiflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data for sending (but does not send it immediately).</p>
<p>It waits in the expectation of more data being sent soon (as it can send them more efficiently by combining them together). To prompt the system to send data now, call <a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output()</a> after calling <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection to enqueue data for. </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer to the data to be enqueued for sending. </td></tr>
    <tr><td class="paramname">len</td><td>Data length in bytes </td></tr>
    <tr><td class="paramname">apiflags</td><td>combination of following flags :<ul>
<li>TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack</li>
<li>TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent, </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if enqueued, another err_t on error </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
